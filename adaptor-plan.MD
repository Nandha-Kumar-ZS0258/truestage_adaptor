# TrueStage â€” Final Implementation Plan

---

## OVERVIEW

```
GOAL:
  When a CU sends data (CSV / JSON / XML) â†’
  it gets mapped, transformed, and ingested
  into a centralized SQL database automatically.

HOW:
  Claude Code generates the adaptor (once per CU)
  Azure Functions execute the adaptor (every data run)
  Service Bus coordinates everything safely
  Lambda Architecture preserves all data

TWO MODES:
  Onboarding Time  â†’ Claude Code does the intelligence
  Runtime          â†’ Azure Functions do the execution
```

---

## PHASE 1: FOUNDATION
### Build The Shared C# Engine (Built Once, Never Changes)

```
TrueStage.Adaptors/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ TrueStage.Core/
â”‚   â”‚   â”œâ”€â”€ Interfaces/
â”‚   â”‚   â”‚   â”œâ”€â”€ ISourceReader.cs        â†’ reads source file
â”‚   â”‚   â”‚   â”œâ”€â”€ IColumnMapper.cs        â†’ maps columns
â”‚   â”‚   â”‚   â”œâ”€â”€ ITransformer.cs         â†’ applies transforms
â”‚   â”‚   â”‚   â”œâ”€â”€ ITargetWriter.cs        â†’ writes to SQL
â”‚   â”‚   â”‚   â””â”€â”€ IEventPublisher.cs      â†’ fires events
â”‚   â”‚   â”œâ”€â”€ Readers/
â”‚   â”‚   â”‚   â”œâ”€â”€ CsvSourceReader.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ JsonSourceReader.cs
â”‚   â”‚   â”‚   â””â”€â”€ XmlSourceReader.cs
â”‚   â”‚   â”œâ”€â”€ Transformers/
â”‚   â”‚   â”‚   â”œâ”€â”€ TrimTransformer.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ DateTransformer.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ DecimalTransformer.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ ValueMapTransformer.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ StripPrefixTransformer.cs
â”‚   â”‚   â”‚   â””â”€â”€ TransformerFactory.cs
â”‚   â”‚   â”œâ”€â”€ Writers/
â”‚   â”‚   â”‚   â””â”€â”€ SqlTargetWriter.cs      â†’ Dapper bulk insert
â”‚   â”‚   â””â”€â”€ Events/
â”‚   â”‚       â””â”€â”€ ServiceBusEventPublisher.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ TrueStage.ConfigLoader/
â”‚   â”‚   â”œâ”€â”€ BlobConfigLoader.cs         â†’ loads CU JSON config
â”‚   â”‚   â””â”€â”€ ConfigValidator.cs          â†’ validates config structure
â”‚   â”‚
â”‚   â”œâ”€â”€ TrueStage.Engine/
â”‚   â”‚   â””â”€â”€ AdaptorEngine.cs            â†’ orchestrates full pipeline
â”‚   â”‚
â”‚   â””â”€â”€ TrueStage.Function/
â”‚       â”œâ”€â”€ FileRouterFunction.cs       â†’ detects file, loads config
â”‚       â”œâ”€â”€ AdaptorEngineFunction.cs    â†’ processes file
â”‚       â”œâ”€â”€ BatchSchedulerFunction.cs   â†’ controls batch concurrency
â”‚       â””â”€â”€ Program.cs                  â†’ 12-factor config from env
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ TrueStage.Core.UnitTests/
    â”œâ”€â”€ TrueStage.Engine.UnitTests/
    â”œâ”€â”€ TrueStage.Integration.Tests/    â†’ one file per CU (generated)
    â””â”€â”€ TrueStage.Regression.Tests/     â†’ runs all CUs after any change
```

**SOLID Rules Applied:**
- Every class has ONE job
- All dependencies injected via interfaces
- TransformerFactory resolves correct transformer â€” open for extension
- AdaptorEngine never knows which CU it's processing â€” config drives it

**12 Factor Rules Applied:**
- Zero hardcoded secrets â€” all from Azure Key Vault
- Stateless functions â€” no shared memory between invocations
- Structured JSON logs to stdout â†’ Application Insights

---

## PHASE 2: TARGET SQL SCHEMA
### The Canonical Destination (Built Once)

```sql
-- CU Registry â€” master list of all onboarded CUs
CREATE TABLE CU_Registry (
    cu_id           VARCHAR(50)  PRIMARY KEY,
    cu_name         VARCHAR(200) NOT NULL,
    status          VARCHAR(20)  DEFAULT 'ONBOARDING',  -- ONBOARDING/ACTIVE/INACTIVE
    adapter_version VARCHAR(10),
    config_path     VARCHAR(500),                        -- blob path to JSON config
    sla_hours       INT          DEFAULT 24,
    onboarded_date  DATETIME     DEFAULT GETUTCDATE()
);

-- Members â€” canonical member table
CREATE TABLE Members (
    member_id        BIGINT       IDENTITY PRIMARY KEY,
    cu_id            VARCHAR(50)  NOT NULL REFERENCES CU_Registry(cu_id),
    source_member_id VARCHAR(100) NOT NULL,
    first_name       VARCHAR(100),
    last_name        VARCHAR(100),
    date_of_birth    DATE,
    email            VARCHAR(255),
    phone            VARCHAR(20),
    member_status    VARCHAR(50),
    account_balance  DECIMAL(18,2),
    branch_code      VARCHAR(20),
    as_of_date       DATE,
    record_hash      VARCHAR(64),                        -- for change detection
    is_current       BIT          DEFAULT 1,
    ingested_at      DATETIME     DEFAULT GETUTCDATE(),
    adapter_version  VARCHAR(10),
    source_file      VARCHAR(500),
    UNIQUE (cu_id, source_member_id)
);

-- Ingestion Log â€” audit trail per file
CREATE TABLE Ingestion_Log (
    job_id        VARCHAR(100) PRIMARY KEY,
    cu_id         VARCHAR(50)  NOT NULL,
    source_file   VARCHAR(500) NOT NULL,
    status        VARCHAR(20)  NOT NULL,                 -- IN_PROGRESS/COMPLETED/FAILED
    total_rows    INT          DEFAULT 0,
    success_rows  INT          DEFAULT 0,
    failed_rows   INT          DEFAULT 0,
    rows_new      INT          DEFAULT 0,
    rows_updated  INT          DEFAULT 0,
    rows_unchanged INT         DEFAULT 0,
    sla_hours     INT,
    sla_met       BIT,
    started_at    DATETIME     DEFAULT GETUTCDATE(),
    completed_at  DATETIME,
    error_summary VARCHAR(MAX)
);

-- Row Error Log â€” row level failures
CREATE TABLE Row_Error_Log (
    error_id      BIGINT       IDENTITY PRIMARY KEY,
    job_id        VARCHAR(100) REFERENCES Ingestion_Log(job_id),
    cu_id         VARCHAR(50),
    row_number    INT,
    raw_data      VARCHAR(MAX),
    error_message VARCHAR(MAX),
    occurred_at   DATETIME     DEFAULT GETUTCDATE()
);
```

---

## PHASE 3: AZURE INFRASTRUCTURE
### The Runtime Platform (Provisioned Once via Terraform)

```
Azure Resources:

Blob Storage
  /incoming/{cu_id}/          â† CU drops files here
  /raw/{cu_id}/{date}/        â† Lambda raw archive (never deleted)
  /configs/                   â† all CU JSON adaptor configs
  /processed/{cu_id}/         â† files moved here after success
  /failed/{cu_id}/            â† files moved here after failure

Event Grid
  Watches /incoming/ container
  Fires on every new blob â†’ no polling needed

Service Bus (5 Topics)
  file-arrived                â† Event Grid fires this
  ingestion-ready             â† FileRouter fires this
  ingestion-started           â† AdaptorEngine fires this
  ingestion-completed         â† AdaptorEngine fires this
  ingestion-failed            â† AdaptorEngine fires this

Azure Functions (2 only â€” regardless of CU count)
  FileRouterFunction          â† routes file to correct config
  AdaptorEngineFunction       â† processes any CU's file
  BatchSchedulerFunction      â† controls concurrency (max 10 at a time)

Azure SQL Database
  CU_Registry, Members, Ingestion_Log, Row_Error_Log

Azure Key Vault
  SQL connection string
  Service Bus connection string
  Blob storage connection string

Application Insights
  Structured logs from all functions
  Dashboard: ingestion rate, error rate, SLA status per CU
```

**Batch Concurrency Control (host.json):**
```json
{
  "extensions": {
    "serviceBus": {
      "maxConcurrentCalls": 10
    }
  }
}
```
Never more than 10 CUs processing simultaneously. Change one number to tune.

---

## PHASE 4: CLAUDE CODE SETUP
### The Adaptor Generator (Set Up Once, Used Forever)

```
.claude/
â”œâ”€â”€ CLAUDE.md                          â† master instructions auto-loaded
â”œâ”€â”€ skills/
â”‚   â”œâ”€â”€ 01-detect-source-format.md    â†’ CSV/JSON/XML detection
â”‚   â”œâ”€â”€ 02-analyze-source-file.md     â†’ columns, types, samples, nulls
â”‚   â”œâ”€â”€ 03-map-columns.md             â†’ source â†’ target mapping
â”‚   â”œâ”€â”€ 04-infer-transforms.md        â†’ what transform each column needs
â”‚   â”œâ”€â”€ 05-generate-mapping-config.md â†’ writes cu_xxx_mapping.json
â”‚   â”œâ”€â”€ 06-generate-tests.md          â†’ writes CUXxxTests.cs
â”‚   â”œâ”€â”€ 07-generate-regression.md     â†’ updates RegressionSuite.cs
â”‚   â”œâ”€â”€ 08-run-and-fix-tests.md       â†’ dotnet test â†’ fix â†’ rerun loop
â”‚   â”œâ”€â”€ 09-validate-config.md         â†’ validates JSON vs target schema
â”‚   â”œâ”€â”€ 10-detect-schema-drift.md     â†’ compares file headers vs config
â”‚   â””â”€â”€ 11-update-memory.md           â†’ logs CU details to memory files
â”‚
â”œâ”€â”€ commands/
â”‚   â”œâ”€â”€ onboard-cu.md                 â†’ /project:onboard-cu
â”‚   â”œâ”€â”€ validate-mapping.md           â†’ /project:validate-mapping
â”‚   â”œâ”€â”€ run-regression.md             â†’ /project:run-regression
â”‚   â””â”€â”€ reprocess-cu.md               â†’ /project:reprocess-cu
â”‚
â””â”€â”€ memory/
    â”œâ”€â”€ onboarded_cus.md              â†’ all CUs, quirks, patterns
    â”œâ”€â”€ known_patterns.md             â†’ reusable transform patterns
    â””â”€â”€ known_issues.md               â†’ past failures + resolutions
```

**CLAUDE.md Key Rules:**
- Always reference /schema/target.sql as canonical destination
- Never generate new C# source â€” only JSON configs + tests
- SOLID: one responsibility per class, inject interfaces
- 12 Factor: no hardcoded secrets, stateless, structured logs
- Lambda: always archive raw file before any processing
- Eventing: always publish started/completed/failed events
- Tests always in /tests/ â€” never mixed with /src/

---

## PHASE 5: CU ONBOARDING FLOW
### What Happens Every Time A New CU Is Added

```
STEP 1: Business Registration
  Contract signed
        â†“
  Admin registers CU in portal
        â†“
  CU_Registry record created (status: ONBOARDING)
        â†“
  Terraform provisions blob containers + Key Vault entry
        â†“
  CU given SFTP/SAS credentials + submission guide


STEP 2: Sample File + Schema Discovery (Claude Code)
  CU drops sample file into /incoming/{cu_id}/
        â†“
  Developer runs in Claude Code:
  "Onboard the new CU files in ./incoming/cu_gamma/"
        â†“
  Claude Code Orchestrator:
    â”œâ”€â”€ Agent 1: reads sample file â†’ detects format, columns, types
    â”œâ”€â”€ Agent 2: reads /schema/target.sql
    â””â”€â”€ Agent 3: reads memory/onboarded_cus.md (past patterns)
        â†“
  Mapping Agent: maps source â†’ target with confidence scores
        â†“
  Transform Agent: infers trim/date/decimal/value_map rules
        â†“
  PAUSE: Shows mapping table to developer
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Source Column   â”‚ Target Column    â”‚ Confidence â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ mem_no          â”‚ member_id        â”‚ HIGH  ğŸŸ¢   â”‚
  â”‚ f_name          â”‚ first_name       â”‚ HIGH  ğŸŸ¢   â”‚
  â”‚ dob             â”‚ date_of_birth    â”‚ HIGH  ğŸŸ¢   â”‚
  â”‚ acct_bal        â”‚ account_balance  â”‚ MEDIUM ğŸŸ¡  â”‚
  â”‚ status          â”‚ member_status    â”‚ MEDIUM ğŸŸ¡  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Developer confirms / corrects


STEP 3: Adaptor Generation (Claude Code)
  Claude Code generates:
    âœ… /configs/cu_gamma_mapping.json   â† adaptor instruction card
    âœ… /tests/.../CUGammaTests.cs       â† integration tests
    âœ… RegressionSuite.cs updated       â† regression entry added
    âœ… memory/onboarded_cus.md updated  â† CU pattern logged
        â†“
  Runs: dotnet build && dotnet test
        â†“
  Auto-fixes any failures
        â†“
  Opens PR: "feat: onboard CU_GAMMA adaptor"


STEP 4: Review + Go Live
  Developer reviews PR
        â†“
  Merges â†’ CI/CD deploys config to blob
        â†“
  End-to-end test in STAGING passes
        â†“
  CU_Registry status: ONBOARDING â†’ ACTIVE
        â†“
  CU notified â€” start sending production files

  WHAT CHANGED IN THE CODEBASE:
    âœ… /configs/cu_gamma_mapping.json   (new file)
    âœ… /tests/.../CUGammaTests.cs       (new file)
    âœ… RegressionSuite.cs               (updated)
    âŒ Zero C# source code changes
    âŒ Zero Azure Function changes
    âŒ Zero infrastructure changes
    âŒ Zero redeployment of engine
```

---

## PHASE 6: RUNTIME FLOW
### What Happens Every Month When CU Sends Data

```
CU drops file â†’ /incoming/cu_gamma/members_20260401.csv
        â†“
Event Grid detects blob â†’ fires FILE_ARRIVED event
        â†“
Service Bus buffers message (maxConcurrentCalls: 10)
        â†“
FileRouterFunction wakes up:
  - looks up CU_Registry â†’ status ACTIVE âœ…
  - loads /configs/cu_gamma_mapping.json
  - detects file format: CSV
  - starts SLA timer
  - creates Ingestion_Log job record
  - fires ingestion-ready event
        â†“
SCHEMA DRIFT CHECK:
  file headers vs config expected headers
  HARD drift (missing col, renamed col) â†’ quarantine + alert âŒ
  SOFT drift (new col added) â†’ warn + continue âš ï¸
  No drift â†’ proceed âœ…
        â†“
LAMBDA â€” RAW ARCHIVE (always first):
  copies file to /raw/cu_gamma/2026-04-01/members_20260401.csv
  raw file never deleted â€” always reprocessable
        â†“
LAMBDA â€” BATCH LAYER:
  full file written to Data Lake (historical record)
        â†“
LAMBDA â€” SPEED LAYER:
  AdaptorEngine processes row by row
  applies column mappings from config
  applies transforms (trim, date, decimal, value_map)
  computes record_hash per row
  compares with last month's hash:
    new record     â†’ INSERT into Members SQL
    changed record â†’ UPDATE Members SQL, version old
    unchanged      â†’ skip (no write needed)
        â†“
DQ RULES RUN:
  member_id: not null, unique âœ…
  account_balance: positive decimal âœ…
  date_of_birth: valid date âœ…
  failed rows â†’ Row_Error_Log
        â†“
ROW COUNT RECONCILIATION:
  file rows == ingested rows âœ…
        â†“
EVENTS FIRED:
  ingestion-completed:
  {
    cu_id: "CU_GAMMA",
    job_id: "job-20260401-cu-gamma",
    total_rows: 5000,
    success_rows: 4998,
    failed_rows: 2,
    rows_new: 45,
    rows_updated: 120,
    rows_unchanged: 4833,
    sla_met: true
  }
        â†“
Ingestion_Log job closed: COMPLETED âœ…
File moved to /processed/cu_gamma/
```

---

## PHASE 7: WHAT HAPPENS AT 100+ CUs

```
Infrastructure:    SAME 2 Azure Functions handle all 100 CUs
Configs:           100 JSON files in /configs/ blob container
Concurrency:       Service Bus limits to 10 CUs at a time
Parallelism:       10 CUs process simultaneously, independently
Adding CU #101:    1 JSON config + 1 test file. Zero else changes.

Monday 9am â€” 100 CUs drop files simultaneously:
  100 messages â†’ Service Bus queue
        â†“
  Batch 1 (6:00am): CU_001â€“CU_010 process in parallel
  Batch 2 (6:10am): CU_011â€“CU_020 process in parallel
  ...
  Batch 10 (7:30am): CU_091â€“CU_100 process in parallel
        â†“
  All 100 done by ~8am
  All events fired
  Dashboard shows all 100 CUs green âœ…
```

---

## DELIVERY SEQUENCE

```
Week 1-2:   Phase 1 â€” Build TrueStage.Core + Engine + Functions
Week 3:     Phase 2 â€” Create target SQL schema
Week 3:     Phase 3 â€” Provision Azure infrastructure (Terraform)
Week 4:     Phase 4 â€” Set up Claude Code (CLAUDE.md + skills + commands)
Week 5:     Phase 5 â€” Onboard first CU manually as reference pattern
Week 5:     Phase 6 â€” Validate full runtime flow end to end
Week 6:     Phase 7 â€” Onboard 2nd and 3rd CU using Claude Code command
Week 7+:    Scale â€” each new CU = 1 Claude Code command + PR review
```

---

## WHAT NEVER CHANGES vs WHAT GROWS

```
BUILT ONCE â€” NEVER CHANGES:
  TrueStage.Core          C# interfaces + transformers + readers
  TrueStage.Engine        pipeline orchestration
  TrueStage.Function      Azure Functions (FileRouter + AdaptorEngine)
  Azure Infrastructure    blob, service bus, SQL, event grid
  Target SQL Schema       canonical tables
  CLAUDE.md               master instructions
  Skill files             reusable Claude Code capabilities

GROWS WITH EACH NEW CU:
  /configs/               +1 JSON file per CU
  /tests/Integration/     +1 test file per CU
  CU_Registry SQL table   +1 row per CU
  memory/onboarded_cus.md +1 entry per CU
```

---

## KEY PRINCIPLES APPLIED THROUGHOUT

| Principle | Where Applied |
|---|---|
| SOLID | TrueStage.Core interfaces, TransformerFactory, AdaptorEngine |
| 12 Factor | Key Vault secrets, stateless functions, structured logs |
| Unit Tests | /tests/ separate from /src/, generated per CU by Claude Code |
| Regression Testing | RegressionSuite runs all CUs after any change |
| Eventing | Service Bus topics: started/completed/failed per ingestion |
| Lambda Architecture | Raw archive â†’ Batch layer â†’ Speed layer â†’ Serving layer |
| Reusable Components | One engine, one set of functions, config drives CU differences |